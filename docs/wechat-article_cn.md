# 6 小时把智能 ToDo 跑通：VibeCoding + Agently 验证“能交付”的 AI 开发新范式

项目仓库：github.com/AgentEra/Agently-NexusTodo  
Agently 框架：github.com/AgentEra/Agently  
Agently 官网：Agently.tech（EN） / Agently.cn（CN）

我是 Agently 团队的运营同学，这篇文章是一份“直播复盘 + 项目复盘”。我们想把一件事讲清楚：  
VibeCoding 很热闹，但一旦进入“智能体/智能系统”开发，难点从来不在“写代码”，而在“把不确定性收住，做成可交付的系统”。

你是否幻想过这样的场景：把需求丢给模型，一路狂点 “Accept”，项目就自动完美交付？  
做一个能跑的 Demo 当然不难，但要让大模型真正融入系统，并且长期稳定运行，难度远超想象。

所以这次我们选了一个人人都懂的题目：智能 ToDo。不是为了“再造一个待办工具”，而是把它当成试验场，验证这对组合：

> Tips（我们想验证的命题）  
> VibeCoding 能不能在工程里落地？Agently 能不能把它变成“跑得稳、交付得出”的智能体系统开发方式？

在 51CTO 的一场直播里（由 Agently 框架核心作者莫欣老师主讲），我们用 VibeCoding 完成了一个端到端系统：Go 后端 + Agently 智能服务 + Electron 桌面端。整体开发与优化约 6 小时，其中直播教学覆盖约 4 小时；Golang 后端由 TRAE 实现，其它部分由 VSCode + Codex 协作完成。

下面我按一条更顺畅的阅读线索来讲：我们怎么设计、怎么行动、难点在哪、Agently 为什么能顶上、你自己的项目怎么照着用。

---

## 一、智能 ToDo：AI 应用开发范式的“试验场”

我们构建的智能 ToDo 是典型的三段式架构，刚好能把智能体系统的关键问题一次性跑全：

1) Go 后端：数据与规则的“坚固地基”  
它负责最稳定的一层：任务的增删改查 API、数据持久化、设备/用户标识。  
它的意义不是“写得多漂亮”，而是把事实来源钉死：数据以它为准，上层智能才能放心做决策与执行。

2) Python 智能服务（auto_agent，基于 Agently）：自然交互的“智慧大脑”  
它负责理解自然语言、承接多轮对话、规划与执行工具调用（多次请求 ToDo 后端查询/写入），并用流式方式把过程推给前端。  
这也是我们最想验证的部分：智能模块到底怎么工程化，才能“不抽风、不兜圈、不靠人肉盯着跑”。

3) Electron 桌面端：用户交互的“友好桥梁”  
它让用户既能像传统应用一样管理待办，又能通过对话完成复杂操作。  
更重要的是，它能把“过程”和“结论”分层展示：进行中看到推理/观察，结束时看到可验证的结论与任务卡片。

我们的开发顺序也刻意遵守一个原则：先稳系统，再加智能。  
先把 ToDo 场景的后端 + 客户端基础架子搭好，让接口与体验可跑通；然后在这个基础上，通过 auto_agent 把智能能力装上去，再用真实接口的场景用例把它一轮轮打磨到可用。

---

## 二、直播复盘：6 小时打造“可控系统”，靠的不是灵感

围绕“怎么把智能模块做成工程交付”这个命题，我问了莫欣老师一个问题：

> Tips（提问）  
> 你最希望观众带走的“一个关键认知”是什么？

莫欣老师给了三个原则（我做了适度整理，但意思不变）：

> Tips（回答要点）  
> 1）SpecDD 不是“形式主义”，它是并行开发的起点。  
> 2）API 文档规范不是“事后补说明书”，它是协作与联调的基准。  
> 3）智能模块要能落地，不能靠“硬写”，要靠框架约束 + 可执行测试把不确定性收住。

这三句话其实指向同一个结论：  
要让 VibeCoding 真正落地，先追求“系统可控”，再追求“系统聪明”。可控的系统，才能准确评估技术组合的优劣，及时发现问题并持续优化。

---

## 三、测试策略：先定规则再并行（不然联调会很惨）

传统 AI 开发很容易陷入“先跑起来再说”的误区。但在智能体系统里，这会把风险放大：  
因为智能模块的不确定性，会把任何协作问题（接口不清、边界不明、数据不同步）放大成线上事故。

所以我们先做三件看起来“慢”的事，用来换后面整体的“快”：

1) SpecDD：先把路线图画出来  
目标、边界、成功标准先写清楚，不然做着做着就变成“模型写爽了，但系统跑不稳”。

2) API 文档规范：先统一沟通语言  
模块之间怎么说话（字段、状态码、示例请求响应）先定好，不然联调就是鸡同鸭讲。

3) 场景用例：先把验收门槛立起来  
把“自然语言指令 -> 多次工具调用 -> 最终写入/查询结果”的关键链路写成脚本，反复跑，反复回归。

> Tips（给读者的直觉）  
> 联调就是照妖镜：你写得再漂亮，一联调就知道“到底哪里在胡说”。

---

## 四、实施路径：从简单到复杂，把智能体系统的难点一次性打穿

选择 ToDo 不是因为它“简单”，而是因为它“刚好覆盖智能体开发的核心难点”：

- 需求表达很口语：用户不会按接口字段说话
- 任务经常是多步的：先查，再筛，再改/删/标记
- 交互必须可信：过程要可见，结论要可验
- 系统必须能回归：不然每次改提示词都是拆盲盒

在 VibeCoding 的过程中，我们还发现一个很实用的组织方法：把多会话当“多小队”来协作。

- 前端一队：桌面端体验、流式气泡、任务卡片等
- 后端一队：API、持久化、设备注册等
- 智能模块一队：语义理解、工具调用、ReAct（思考-行动-观察）循环、SSE 输出协议等

随着项目进入联调阶段，很多问题会跨模块出现，这时要敢于“把权限与上下文打开”，让同一个会话能看到全局，才能把智能问题真正修干净。

---

## 五、避坑指南：硬写智能模块的四大陷阱

如果你让模型把智能模块“硬写到底”，最常见的坑通常是这些：

1) “Accept All” 陷阱  
Karpathy 在某处提到 “vibe coding / accept all” 的语境后，引发了大量讨论。现实里最常见的翻车方式就是：代码越写越多，你越来越不理解它，修 bug 变成“碰运气”。

2) 质量回归拖长尾巴  
看起来产出快，但后续返工、review、修 bug 的成本会把优势吃掉，越到后面越难维护。

3) 安全盲区 + 过度自信  
代码更容易带坑，同时人更容易“以为没坑”。例如 Dan Boneh 团队的相关研究与讨论，就提醒过“错误率上升 + 过度自信”的组合风险。

4) 供应链风险更容易被触发  
幻觉依赖、包名混淆等路径在 AI 时代更常见、更隐蔽；安全研究里甚至把这类风险称为 “slopsquatting / package hallucination”。

这些坑的共同点是：它们并不“高级”，但会在真实项目里反复发生，而且往往发生在你最不想出问题的地方（联调、上线、交付、演示）。

---

## 六、Agently：VibeCoding 的最佳搭档，靠的是工程化能力而不是“玄学”

没有框架支持的 VibeCoding，就像开车没有方向盘：能动，但不稳。  
Agently 在这次项目里，真正帮我们顶住的是三类能力（也都能在 Agently 文档与样例里直接找到对应模板）：

1) 结构化输出：先把输出变成“可校验的数据”  
用 Output Format（结构化输出约束）把结果写成明确的数据结构，而不是一段“解释”。  
再用 ensure_keys（关键字段保障）做兜底：关键字段偶发缺失时自动重试（常见做法是 1～3 次），把解析稳定性拉上来。

2) 事件化流式返回：过程可见，结论可验  
Agently 把模型响应统一成事件流（例如 delta / reasoning_delta / tool_calls / done / error）。  
当输出是 Output Format 时，还可以用 Instant（结构化流式解析）拿到“字段路径 + 增量”，这让前端展示不必靠猜，更不必靠正则。

3) TriggerFlow 编排：把多步任务写成可读、可调、可测的流程  
TriggerFlow 的核心是“信号 + 节点 + 运行态”：  
事件（event）触发、运行态数据（runtime_data）驱动、分支结果 collect 汇合、runtime_stream 输出过程、必要时 stop_stream 停止流。  
它解决的是智能体系统最要命的一件事：多步任务的控制流别写成一坨 if-else，而要写成可以回归、可以复盘、可以扩展的编排。

> Tips（这一段的落点）  
> Agently 的价值不在“让模型更会说”，而在“让系统更可控”：可约束、可编排、可验证。

如果你想对照学习，建议直接看 Agently 仓库里这些入口（都在同一个仓库内）：  
docs/agent-docs.md、docs/output-control/ensure-keys.md、docs/model-response/streaming.md、docs/triggerflow/concepts.md  
以及 examples/step_by_step/03-output_format_control.py、06-streaming.py、07-tools.py

---

## 七、如果换成你的项目：这 3 类问题最值得“照着用一次”

很多读者看完会问：这些听起来都对，但落到我自己的项目上，我到底该从哪儿下手？

我把它收敛成 3 类最常见的“卡点”，你可以对照自己现在的处境：

1) 你卡在“输出不稳定、字段缺失、解析脆弱”  
可以试试：先用 Output Format 把输出写成结构，再用 ensure_keys 把关键字段兜住。  
当你的结果“能被程序稳定读取”，系统才谈得上可测、可迭代。

2) 你卡在“多步任务做不完、反复兜圈、工具调用失控”  
可以试试：把流程显式化，用 TriggerFlow 把“什么时候该查、什么时候该写、什么时候该停”写清楚；再用场景脚本做回归门槛，避免一修就崩。

3) 你卡在“能跑但不敢交付、联调全靠人肉盯着”  
可以试试：把 SpecDD + API 文档规范当成第一产物，把真实接口集成用例当成验收门槛，让“能用”变成“可回归、可迭代”。

我们也把这次踩坑与修复写进了项目仓库的 skills 里，作为“下一次别再踩”的清单：  
github.com/AgentEra/Agently-NexusTodo/blob/main/auto_agent/docs/skills/

---

## 八、加入我们：社区、招募与合作

如果你正在把大模型嵌进业务系统，或者想把多轮对话、工具调用、流式交互、复杂流程编排做得更稳，欢迎来 Agently 社区一起讨论、一起踩坑、一起把坑填平：

- 微信讨论群入口：Agently.tech 或 github.com/AgentEra/Agently（主页可找到加入方式）
- 申请表：doc.weixin.qq.com/forms/AIoA8gcHAFMAScAhgZQABIlW6tV3l7QQf

同时，我们也有两个明确的倡议，欢迎你一键联系：

1) 加入团队（含实习）  
如果你对 AI 应用开发技术探索有热情，欢迎加入 Agently 团队。简历请发送至：hr@agently.tech（也欢迎实习生投递）。

2) 商务合作  
如有商务合作需求，欢迎发送邮件至：business@agently.tech

